use rand::Rng;
use std::cmp::Ordering;
use std::ops::{AddAssign, SubAssign};

/// Push new elements generated by repeatedly by calling f onto the end of v.
#[allow(dead_code)]
pub fn extend_vec_with<T, F>(v: &mut Vec<T>, needed_index: usize, mut f: F)
    where F: FnMut() -> T
{
    if needed_index >= v.len() {
        let difference = 1 + needed_index - v.len();
        v.extend((0..difference).map(|_| f()));
    }
}

#[allow(dead_code)]
pub fn cumulative_sum<T>(array: &mut [T])
    where T: AddAssign<T> + Clone
{
    for i in 1..array.len() {
        array[i] += array[i - 1].clone();
    }
}

#[allow(dead_code)]
pub fn un_cumulative_sum<T>(array: &mut [T])
    where T: SubAssign<T> + Clone
{
    for i in (1..array.len()).rev() {
        array[i] -= array[i - 1].clone();
    }
}

#[allow(dead_code)]
pub fn weighted_index_cumulative_array<R>(rng: &mut R, array: &[f64]) -> usize
    where R: Rng
{
    let max_cumulative_weight = array[array.len() - 1];
    let target_cumulative_weight = max_cumulative_weight as f64 * rng.next_f64();
    match array.binary_search_by(|w| {
                                     w.partial_cmp(&target_cumulative_weight)
                                         .unwrap_or(Ordering::Equal)
                                 }) {
        Ok(index) => index + 1,
        Err(index) => index,
    }
}

#[cfg(test)]
mod test {
    use super::{cumulative_sum, extend_vec_with, weighted_index_cumulative_array};
    use rand::SeedableRng;
    use rand::XorShiftRng;

    #[test]
    fn extend_vec_simple() {
        let mut x = vec![1, 1, 1];
        extend_vec_with(&mut x, 3, || 2);
        assert_eq!(x, vec![1, 1, 1, 2]);
    }

    #[test]
    fn cumulative_sum_simple() {
        let mut x: Vec<i64> = vec![1, 0, -1];
        cumulative_sum(&mut x);
        assert_eq!(x, vec![1, 1, 0]);
    }

    #[test]
    fn weighted_index_zeros() {
        let mut rng = XorShiftRng::from_seed([0xde, 0xad, 0xbe, 0xef]);
        let mut array = vec![0.0f64; 1024];
        let expected_index = 100;
        array[expected_index] = 1.0;
        cumulative_sum(&mut array);
        let index = weighted_index_cumulative_array(&mut rng, &mut array);
        assert_eq!(expected_index, index);
    }
}
